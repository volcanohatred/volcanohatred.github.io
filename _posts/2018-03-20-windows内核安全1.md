---
layout:     post
title:      windows内核安全(一)
subtitle:   系统硬件基础篇
date:       2018-03-20
author:     volcanohatred
header-img: img/articles/内核/title.jpg
catalog: true
tags:
    - 内核
    - windows
    - 系统安全
    - 编程
---
# 硬件基础
## IA-32（英特尔32位体系架构）内存模型  
### 内存平面模型
在此情况下，线性地址等同于物理地址，但不总是如此，当拥有完善的内存保护机制时，线性地址就处于过渡状态，所以也就完全不等于物理地址了。  
![cpu](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/内核/1/图片1.png)  
### 内存分段模型
在分段内存模型中，内存呈现在段的不同区域，某段中某字节由逻辑地址指定，逻辑地址由段选择器和偏移地址(有效地址)组成。段选择器指定被引用的段，偏移地址用于指定段中字节的位置。  
![cpu](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/内核/1/图片2.png)  
## 操作模式：
### 实模式
实模式为分段模型的一个实例，在实模式中，内存中一个字节的逻辑地址由一个16位的段选择器和一个16位的有效地址组成，段选择器中存储一个64KB大小的内存基地址(注意：此处为字节寻址，一个内存单元为一个字节，16位则表示2^16个字节，也就是64KB)，有效地址指定被访问内存段的段内偏移，有效地址和段选择器中的内容相加构成字节的物理地址。    
![cpu](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/内核/1/图片3.png)  
在8086处理器中，20位地址总线被16位值访问的方法如上，通过这个隐式0来解决。    
![cpu](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/内核/1/图片4.png)  
注意右边为物理地址空间  
### 保护模式
在IA-32体系中，保护模式也是分段内存模型的实列，区别在于物理地址的解析过程不仅由处理器独自完成，操作系统(windows,linux等)还必须通过维护大量帮助处理器完成工作的特殊表来与处理器合作，这些特殊表为内存保护，按需分页等等附属功能提供了支持。  
在保护模式中，还需要大量额外的寄存器来管理执行环境，包括5个控制寄存器(CR0-CR4),全局描述符表寄存器GDTR，本地描述符表寄存器LDTR，中断描述符表寄存器IDTR。
在保护模式中，IA-32处理器使用分段和分页两种机制实现内存保护。    
分页是可选的，但**保护模式分段是强制的**，在此情况下，段选择器的大小是16位，有效地址的值是32位。保护模式中段选择器不是用来存储物理内存中的物理地址(注意是物理地址)，而是索引了一个二进制结构，该结构包含了线性地址(注意是线性地址)空间中段的细节，该结构称为描述符表，里面的项被称为段描述符。  
描述符表分为两类：全局描述符表(GDT)和局部描述符表(LDT),GDT是强制存在的，每一个运行在IA-32上面的操作系统在启动时必须创建一个GDT，而且整个系统只有一个被任务共享的GDT，与之对应的LDT则是可选的，他能被单一任务使用。    
![cpu](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/内核/1/图片5.png)  
图中GDTR是一个特殊寄存器，用来保存GDT基地址，GDTR寄存器大小为48位，低16位决定GDT大小，其余的32位存储GDT的起始线性地址。