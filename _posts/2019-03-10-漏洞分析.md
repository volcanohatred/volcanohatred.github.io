---
layout:     post
title:      漏洞分析
subtitle:   
date:       2019-03-10
author:     volcanohatred
header-img: img/articles/漏洞分析/title.jpg
catalog: true
tags:
    - 漏洞
---

这几天从公司离职清闲了不少，所以抽空写一篇常见漏洞的基础知识，供自己以后参考学习。

## 缓冲区溢出
溢出的根本原因：冯洛伊曼计算机体系未对数据代码进行区分
### 1.1 栈溢出
想要弄明白栈溢出，首先得知道三种调用约定：cdecl，stdcall和fastcall。
cdecl是c/c++默认的调用方式，stdcall是windowsAPI默认的调用方式。在x86系统中，cdecl由调用函数负责栈平衡，而stdcall和fastcall都是被调用函数自己负责栈平衡。入栈方面都是从右往左依次入栈，但是fastcall前两个参数要放到ecx和edx中。  
![1](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/漏洞分析/图片1.png)  
在vs2017中进行如下测试：  
```
int _cdecl func1(char a, short b, int c)
{
	return a + b + c;
}

int _stdcall func2(char a, short b, int c)
{
	return a + b + c;
}

int _fastcall func3(char a, short b, int c)
{
	return a + b + c;
}
int main()
{
	func1('v', 1, 2);
	func2('v', 1, 2);
	func3('v', 1, 2);
	return 0;
}
```  
debug版对应的汇编代码如下：  
```
int _cdecl func1(char a, short b, int c)
{
 push        ebp       //老ebp入栈
 mov         ebp,esp   //老esp和ebp同位置
 sub         esp,0C0h  //esp上移，局部变量空间
 push        ebx       //ebx,esi,edi无备份。
 push        esi  
 push        edi  
 lea         edi,[ebp-0C0h]  //以下4行代码让cc存满局部变量空间
 mov         ecx,30h  
 mov         eax,0CCCCCCCCh   //cc为断点指令
 rep stos    dword ptr es:[edi]  
	return a + b + c;
 movsx       eax,byte ptr [a]  
 movsx       ecx,word ptr [b]  
 add         eax,dword ptr [c]  
 add         eax,ecx    //返回值存放在eax中
}
 pop         edi        //ebx,esi,edi出栈
 pop         esi  
 pop         ebx  
 mov         esp,ebp  //ebp位置传给esp（esp下移）
 pop         ebp      //老ebp重新写入
 ret                  //直接返回，由调用者清理栈。ret会跳到eip所指位置
int _stdcall func2(char a, short b, int c)
{
 push        ebp  
 mov         ebp,esp  
 sub         esp,0C0h  
 push        ebx  
 push        esi  
 push        edi  
 lea         edi,[ebp-0C0h]  
 mov         ecx,30h  
 mov         eax,0CCCCCCCCh  
 rep stos    dword ptr es:[edi]  
	return a + b + c;
 movsx       eax,byte ptr [a]  
 movsx       ecx,word ptr [b]  
 add         eax,dword ptr [c]  
 add         eax,ecx  
}
 pop         edi  
 pop         esi  
 pop         ebx  
 mov         esp,ebp  
 pop         ebp  
 ret         0Ch   //被调用者栈平衡
int _fastcall func3(char a, short b, int c)
{
 push        ebp  
 mov         ebp,esp  
 sub         esp,0D8h  
 push        ebx  
 push        esi  
 push        edi  
 push        ecx  
 lea         edi,[ebp-0D8h]  
 mov         ecx,36h  
 mov         eax,0CCCCCCCCh  
 rep stos    dword ptr es:[edi]  
 pop         ecx  
 mov         word ptr [b],dx  
 mov         byte ptr [a],cl  
	return a + b + c;
 movsx       eax,byte ptr [a]  
	return a + b + c;
 movsx       ecx,word ptr [b]  
 add         eax,dword ptr [c]  
 add         eax,ecx  
}
 pop         edi  
 pop         esi  
 pop         ebx  
 mov         esp,ebp  
 pop         ebp  
 ret         4  
  

int main()
{
 push        ebp  
 mov         ebp,esp  
 sub         esp,0C0h  
 push        ebx  
 push        esi  
 push        edi        //debug版本特有调试代码
 lea         edi,[ebp-0C0h]  
 mov         ecx,30h  
 mov         eax,0CCCCCCCCh  
 rep stos    dword ptr es:[edi]  
	func1('v', 1, 2);
 push        2         //入栈顺序
 push        1           
 push        76h  
 call        _func1 (0BC1366h)   //调用函数
 add         esp,0Ch   //调用者栈平衡
	func2('v', 1, 2);
 push        2  
 push        1  
 push        76h  
 call        _func2@12 (0BC135Ch)  
	func3('v', 1, 2);
 push        2  
 mov         edx,1       //前两个放入寄存器
 mov         cl,76h  
 call        @func3@12 (0BC1361h)  
	return 0;
 xor         eax,eax  
}
 pop         edi  
 pop         esi  
 pop         ebx  
 add         esp,0C0h  
 cmp         ebp,esp  
 call        __RTC_CheckEsp (0BC111Dh)  
 mov         esp,ebp  
 pop         ebp  
 ret  
```  
以func1为例，栈结构如下：  
![1](https://raw.githubusercontent.com/volcanohatred/volcanohatred.github.io/master/img/articles/漏洞分析/图片3.png)  
简单了解了调用约定，来看看shellcode。
shellcode就是一段可执行的机器码的十六进制编码字符串，如汇编代码call eax可写成D0FF
看一个简单的弹计算器代码：  
```
"\x8B\xE5" //MOV ESP, EBP
"\x55" //PUSH EBP
"\x8B\xEC" //mov ebp, esp
"\x33\xFF" //xor edi,edi
"\x57"//push edi
"\x83\xEC\x08" //sub esp,08h
"\xC6\x45\xF4\x6D"//mov byte ptr [ebp-0ch],'m'
"\xC6\x45\xF5\x73"//'s'
"\xC6\x45\xF6\x76"//'v'
"\xC6\x45\xF7\x63"//'c'
"\xC6\x45\xF8\x72"//'r'
"\xC6\x45\xF9\x74"//'t'
"\xC6\x45\xFA\x2E"//'.'
"\xC6\x45\xFB\x64"//'d'
"\xC6\x45\xFC\x6C"//'l'
"\xC6\x45\xFD\x6C"//'l'
"\x8D\x45\xF4" //lea eax, [ebp-0ch]
"\x50" //push eax
"\xB8\x7B\x1D\x80\x7C" //mov eax, 7C801D7Bh address of loadlibrary
"\xFF\xD0" //call eax
"\x33\xDB" //xor ebx, ebx
"\x53" //push ebx
"\x68\x2E\x65\x78\x65" //push 'exe.'
"\x68\x63\x61\x6C\x63" //push 'clac'
"\x8B\xC4" //mov eax, esp
"\x50" //push eax
"\xB8\xC7\x93\xBF\x77" //mov eax, 77BF93C7h address of system
"\xFF\xD0" //call eax
"\xB8\xFA\xCA\x81\x7C" //mov eax, 7c81cafah address of exitprocess
"\xFF\xD0"//call eax
```  
思路-->C语言程序--》汇编程序--》嵌入汇编改写--》机器码
汇编窗口获得汇编程序
### 1.2 堆溢出
### 1.3 SEH
### 1.4 HEAP-SPRAY

